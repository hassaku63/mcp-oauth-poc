# MCP における認可の概要

## 要約
MCP（Model Context Protocol）はエージェントとツール/リソース間のやり取りを標準化するプロトコルで、独自の認証・認可方式を規定しません。接続レイヤでのアクセス制御（例: API キー/OAuth/TLS）と、サーバが公開する機能範囲の最小化（tools/resources）、クライアント側のユーザー承認フロー（Permissions）を組み合わせて権限制御を実現します。

## 位置付け
- 認証・認可の実装は MCP の外側（接続方式やサーバ実装）に委ねられる。
- MCP は「何を公開するか」「実行時にどう承認を取るか」を記述・交渉するための枠組みを提供する。

## 認可の実現ポイント
1. 接続レイヤ（プロトコル外の認証/認可）
  - `stdio` などローカル接続: 追加の認証なし（OS のローカル権限に依存）。
  - `ws`/`http(s)` などリモート接続: API キーや OAuth、TLS クライアント認証などでサーバが接続を制御（MCP 規格外）。
2. 最小権限の公開（tools/resources）
  - サーバは提供可能な `tools`（操作）や `resources`（読み書き対象）を明示。未公開の機能には到達不可。
  - `resourceTemplates` や `roots` でパス境界を定義し、範囲外は拒否。
3. ユーザー承認（Permissions）
  - 破壊的/機密操作（例: ファイル書込、外部到達）に対し、サーバが権限リクエストを発行。
  - クライアントは UI でユーザーに確認し、許可/拒否や一時・永続の方針を適用。
4. 能力交渉（capabilities）
  - 初期化で双方の対応機能（tools/resources/prompts/permissions 等）を宣言し、どの承認フロー・機能を使うか合意。

## OAuth 等との関係
- MCP 自体はトークン発行/検証を扱わない。
- サーバが外部サービスへ到達する際は、サーバ内部で OAuth（PKCE/デバイスコード等）を完了し、その結果得た権限で MCP のツール/リソースとして機能を提供する。
- つまり「外向きの認可（外部 API）」と「エージェント向けの権限制御（MCP 公開面）」を分離するのが基本設計。

## 典型パターン
- ローカルサーバ（stdio）: 公開機能を最小化 + クライアントの承認プロンプトで危険操作を都度確認。
- リモートサーバ（wss）: 接続時は API キー/OAuth/TLS でアクセス制御 + 公開機能の最小化 + クライアント承認 UI。

## セキュリティの着眼点
- 最小権限: 必要な tool/resource のみ公開し、書込・外部到達は明示的に分離。
- 明確な境界: `roots`/テンプレートでパス境界を固定し、ディレクトリトラバーサル等を禁止。
- 承認の粒度: 操作名・パス・スコープ・回数などで細かく許可を管理。
- 監査と可視化: クライアントでの承認ログ、サーバでの実行ログを整備。

## まとめ
MCP の認可は「接続の保護（プロトコル外）」と「公開機能の最小化＋実行時承認（プロトコル内の合意）」の二層構えで運用します。OAuth などの外部認可はサーバ内で完結させ、その上でエージェントに必要最小限の操作だけを安全に公開する、という責務分担が基本です。

